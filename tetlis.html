<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML テトリス</title>
    <!-- Tailwind CSSとGoogle Fontsを読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* カスタムスタイル */
        :root {
            --board-bg: #0a0a0a;
            --grid-color: #222;
            --text-color: #eee;
            --accent-color: #00ffdd;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            touch-action: manipulation; /* ダブルタップによるズームを無効化 */
        }

        /* ゲームキャンバスのピクセル化レンダリング */
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* カスタムボタンのスタイル */
        .control-btn {
            transition: all 0.1s ease;
            user-select: none; /* ボタンのテキスト選択を無効化 */
        }
        .control-btn:active {
            transform: scale(0.95);
            background-color: #4f46e5;
        }
    </style>
</head>
<body class="bg-gray-900 text-[var(--text-color)] flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-2xl sm:text-4xl text-center mb-4 text-[var(--accent-color)] tracking-wider">TETRIS</h1>

        <!-- ゲーム全体のコンテナ -->
        <div class="flex flex-col md:flex-row justify-center items-start gap-4">

            <!-- ゲームボード -->
            <div class="relative">
                <canvas id="gameCanvas" class="border-2 border-gray-700 rounded-lg shadow-2xl shadow-cyan-500/20"></canvas>
                <!-- ゲームオーバー/スタート画面 -->
                <div id="overlay" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center rounded-lg">
                    <div id="startScreen">
                        <h2 class="text-3xl text-yellow-400 mb-4">Ready?</h2>
                        <button id="startButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-md text-xl animate-pulse">
                            START
                        </button>
                    </div>
                    <div id="gameOverScreen" class="hidden text-center">
                        <h2 class="text-4xl text-red-500 mb-4">GAME OVER</h2>
                        <button id="restartButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-md text-xl">
                            RESTART
                        </button>
                    </div>
                </div>
            </div>

            <!-- 情報パネル -->
            <div class="w-full md:w-48 flex flex-row md:flex-col gap-4 justify-around text-center">
                <div class="bg-gray-800 p-3 rounded-lg flex-1">
                    <h2 class="text-sm text-[var(--accent-color)]">SCORE</h2>
                    <p id="score" class="text-lg mt-1">0</p>
                </div>
                <div class="bg-gray-800 p-3 rounded-lg flex-1">
                    <h2 class="text-sm text-[var(--accent-color)]">LINES</h2>
                    <p id="lines" class="text-lg mt-1">0</p>
                </div>
                <div class="bg-gray-800 p-3 rounded-lg flex-1">
                    <h2 class="text-sm text-[var(--accent-color)]">LEVEL</h2>
                    <p id="level" class="text-lg mt-1">0</p>
                </div>
                <div class="bg-gray-800 p-4 rounded-lg hidden md:block">
                    <h2 class="text-sm text-[var(--accent-color)] mb-2">NEXT</h2>
                    <canvas id="nextCanvas" width="80" height="80"></canvas>
                </div>
            </div>
        </div>
        
        <!-- モバイル用コントロールボタン -->
        <div class="mt-6 md:hidden w-full max-w-sm mx-auto">
            <div class="flex justify-center mb-2">
                 <button id="rotateBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-lg font-bold">Rotate</button>
            </div>
            <div class="flex justify-between items-center">
                <button id="leftBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-3xl font-bold">←</button>
                <button id="rightBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-3xl font-bold">→</button>
            </div>
            <div class="flex justify-center mt-2">
                 <button id="downBtn" class="control-btn bg-indigo-600 text-white rounded-full h-20 w-20 flex items-center justify-center text-3xl font-bold">↓</button>
            </div>
        </div>

    </div>

    <script>
        // DOM要素の取得
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextContext = nextCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');
        const overlay = document.getElementById('overlay');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');

        // CSS変数から実際の色を取得（Canvas APIはCSS変数を直接解釈できないため）
        const rootStyles = getComputedStyle(document.documentElement);
        const boardBgColor = rootStyles.getPropertyValue('--board-bg').trim();
        const gridColor = rootStyles.getPropertyValue('--grid-color').trim();

        // ゲームの定数
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const NEXT_BLOCK_SIZE = 20;

        // キャンバスのサイズ設定
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        // テトリミノ（ブロック）の定義 (4つの回転状態を含む)
        const TETROMINOES = {
            'I': {
                shapes: [
                    [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
                    [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]],
                    [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
                    [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]]
                ], color: '#00ffff'
            },
            'J': {
                shapes: [
                    [[1,0,0], [1,1,1], [0,0,0]],
                    [[0,1,1], [0,1,0], [0,1,0]],
                    [[0,0,0], [1,1,1], [0,0,1]],
                    [[0,1,0], [0,1,0], [1,1,0]]
                ], color: '#0000ff'
            },
            'L': {
                shapes: [
                    [[0,0,1], [1,1,1], [0,0,0]],
                    [[0,1,0], [0,1,0], [0,1,1]],
                    [[0,0,0], [1,1,1], [1,0,0]],
                    [[1,1,0], [0,1,0], [0,1,0]]
                ], color: '#ff7f00'
            },
            'O': {
                shapes: [
                    [[1,1], [1,1]], [[1,1], [1,1]],
                    [[1,1], [1,1]], [[1,1], [1,1]]
                ], color: '#ffff00'
            },
            'S': {
                shapes: [
                    [[0,1,1], [1,1,0], [0,0,0]],
                    [[0,1,0], [0,1,1], [0,0,1]],
                    [[0,0,0], [0,1,1], [1,1,0]],
                    [[1,0,0], [1,1,0], [0,1,0]]
                ], color: '#00ff00'
            },
            'T': {
                shapes: [
                    [[0,1,0], [1,1,1], [0,0,0]],
                    [[0,1,0], [0,1,1], [0,1,0]],
                    [[0,0,0], [1,1,1], [0,1,0]],
                    [[0,1,0], [1,1,0], [0,1,0]]
                ], color: '#800080'
            },
            'Z': {
                shapes: [
                    [[1,1,0], [0,1,1], [0,0,0]],
                    [[0,0,1], [0,1,1], [0,1,0]],
                    [[0,0,0], [1,1,0], [0,1,1]],
                    [[0,1,0], [1,1,0], [1,0,0]]
                ], color: '#ff0000'
            }
        };
        const TETROMINO_KEYS = Object.keys(TETROMINOES);

        // ゲームの状態
        let board = createEmptyBoard();
        let currentTetromino;
        let nextTetromino;
        let score = 0;
        let lines = 0;
        let level = 0;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isGameOver = false;
        let animationFrameId;
        let tetrominoBag = []; // 7種類のブロックが均等に出るようにするための袋

        // ボードを初期化する関数
        function createEmptyBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        // テトリミノの袋を初期化・補充する関数
        function fillTetrominoBag() {
            const shuffledKeys = [...TETROMINO_KEYS];
            for (let i = shuffledKeys.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledKeys[i], shuffledKeys[j]] = [shuffledKeys[j], shuffledKeys[i]];
            }
            tetrominoBag = shuffledKeys;
        }

        // 新しいテトリミノを生成する関数
        function createTetromino() {
            if (tetrominoBag.length === 0) {
                fillTetrominoBag();
            }
            const type = tetrominoBag.pop();
            const tetrominoDef = TETROMINOES[type];
            return {
                type: type,
                shape: tetrominoDef.shapes[0],
                color: tetrominoDef.color,
                x: Math.floor(COLS / 2) - Math.floor(tetrominoDef.shapes[0][0].length / 2),
                y: 0,
                rotation: 0
            };
        }

        // 描画関連の関数
        function draw() {
            if (!context) return;
            context.fillStyle = boardBgColor;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = gridColor;
            for (let x = 0; x < COLS; x++) {
                for (let y = 0; y < ROWS; y++) {
                    context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            drawMatrix(board, { x: 0, y: 0 }, context, BLOCK_SIZE);
            if (currentTetromino) {
                drawMatrix(currentTetromino.shape, { x: currentTetromino.x, y: currentTetromino.y }, context, BLOCK_SIZE, currentTetromino.color);
            }
        }
        
        function drawMatrix(matrix, offset, ctx, blockSize, colorOverride = null) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = colorOverride || value;
                        ctx.fillRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                        ctx.strokeStyle = boardBgColor;
                        ctx.strokeRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                    }
                });
            });
        }
        
        function drawNext() {
            if (!nextContext || !nextTetromino) return;
            nextContext.fillStyle = boardBgColor;
            nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            const shape = nextTetromino.shape;
            const color = nextTetromino.color;
            const x = (nextCanvas.width / NEXT_BLOCK_SIZE - shape[0].length) / 2;
            const y = (nextCanvas.height / NEXT_BLOCK_SIZE - shape.length) / 2;
            drawMatrix(shape, {x, y}, nextContext, NEXT_BLOCK_SIZE, color);
        }

        // ゲームロジック
        function update(time = 0) {
            if (isGameOver) return;
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                drop();
            }
            draw();
            animationFrameId = requestAnimationFrame(update);
        }
        
        function reset() {
            board = createEmptyBoard();
            fillTetrominoBag();
            currentTetromino = createTetromino();
            nextTetromino = createTetromino();
            score = 0;
            lines = 0;
            level = 0;
            isGameOver = false;
            updateUI();
            drawNext();
        }

        function drop() {
            if (!currentTetromino) return;
            currentTetromino.y++;
            if (checkCollision()) {
                currentTetromino.y--;
                merge();
                clearLines();
                currentTetromino = nextTetromino;
                nextTetromino = createTetromino();
                drawNext();
                if (checkCollision()) {
                    gameOver();
                }
            }
            dropCounter = 0;
        }

        function hardDrop() {
            if (!currentTetromino) return;
            while (!checkCollision()) {
                currentTetromino.y++;
            }
            currentTetromino.y--;
            drop();
        }

        function move(dir) {
            if (!currentTetromino) return;
            currentTetromino.x += dir;
            if (checkCollision()) {
                currentTetromino.x -= dir;
            }
        }
        
        function rotate() {
            if (!currentTetromino) return;

            const originalRotation = currentTetromino.rotation;
            const originalX = currentTetromino.x;
            const originalY = currentTetromino.y;

            const newRotation = (originalRotation + 1) % 4;
            currentTetromino.rotation = newRotation;
            currentTetromino.shape = TETROMINOES[currentTetromino.type].shapes[newRotation];

            // 壁キックのロジック
            const kicks = [[0, 0], [-1, 0], [1, 0], [0, -1]]; // 基本的なキック
            if (currentTetromino.type === 'I') {
                kicks.push([-2, 0], [2, 0]); // Iミノ用の追加キック
            }

            for (const [kickX, kickY] of kicks) {
                currentTetromino.x = originalX + kickX;
                currentTetromino.y = originalY + kickY;
                if (!checkCollision()) {
                    return; // 回転成功
                }
            }

            // すべてのキックが失敗した場合、回転を元に戻す
            currentTetromino.rotation = originalRotation;
            currentTetromino.shape = TETROMINOES[currentTetromino.type].shapes[originalRotation];
            currentTetromino.x = originalX;
            currentTetromino.y = originalY;
        }

        function checkCollision() {
            const { shape, x, y } = currentTetromino;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col] !== 0) {
                        const newX = x + col;
                        const newY = y + row;
                        if (newX < 0 || newX >= COLS || newY >= ROWS || (board[newY] && board[newY][newX] !== 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge() {
            const { shape, color, x, y } = currentTetromino;
            shape.forEach((row, r) => {
                row.forEach((value, c) => {
                    if (value !== 0) {
                        if (y + r >= 0) { // 画面外（上部）にマージしないように
                           board[y + r][x + c] = color;
                        }
                    }
                });
            });
        }
        
        function clearLines() {
            let linesCleared = 0;
            outer: for (let y = ROWS - 1; y >= 0; y--) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                linesCleared++;
                y++;
            }
            if(linesCleared > 0) {
                updateScore(linesCleared);
            }
        }

        function updateScore(cleared) {
            const linePoints = [0, 40, 100, 300, 1200];
            score += linePoints[cleared] * (level + 1);
            lines += cleared;
            level = Math.floor(lines / 10);
            dropInterval = Math.max(100, 1000 - level * 50);
            updateUI();
        }

        function updateUI() {
            scoreElement.innerText = score;
            linesElement.innerText = lines;
            levelElement.innerText = level;
        }
        
        function startGame() {
            reset();
            overlay.classList.add('hidden');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            lastTime = 0;
            dropCounter = 0;
            update();
        }

        function gameOver() {
            isGameOver = true;
            cancelAnimationFrame(animationFrameId);
            gameOverScreen.classList.remove('hidden');
            startScreen.classList.add('hidden');
            overlay.classList.remove('hidden');
        }

        // イベントリスナー
        document.addEventListener('keydown', event => {
            if (isGameOver) return;
            if (event.key === 'ArrowLeft' || event.key === 'a') {
                move(-1);
            } else if (event.key === 'ArrowRight' || event.key === 'd') {
                move(1);
            } else if (event.key === 'ArrowDown' || event.key === 's') {
                drop();
            } else if (event.key === 'ArrowUp' || event.key === 'w') {
                rotate();
            } else if (event.key === ' ') {
                event.preventDefault(); // スペースバーでのスクロールを防止
                hardDrop();
            }
        });

        // モバイル用コントロール
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const downBtn = document.getElementById('downBtn');
        const rotateBtn = document.getElementById('rotateBtn');

        leftBtn.addEventListener('click', () => move(-1));
        rightBtn.addEventListener('click', () => move(1));
        downBtn.addEventListener('click', () => drop());
        rotateBtn.addEventListener('click', () => rotate());

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', () => {
             gameOverScreen.classList.add('hidden');
             startGame();
        });

        // 初期描画
        draw();
    </script>
</body>
</html>

